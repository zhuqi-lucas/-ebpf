# 本章内容会深入分析eBPF程序怎么从源码到执行的整体流程。
![alt text](image.png)
如上图所示. 大概流程是，C (or Rust) 源码首先编译成eBPF的字节码，然后JIT即时编译或者解释成本地的机器码，然后CPU运行机器码。后续我们会进行更加深入的分析。
eBPF程序是一组eBPF字节码指令。虽然可以像编写汇编语言一样直接编写eBPF字节码，但人们通常觉得使用高级编程语言更容易一些。目前eBPF代码是用C语言编写的，然后编译成eBPF字节码。从概念上讲，这些字节码在内核中的eBPF虚拟机中运行。

# eBPF虚拟机
eBPF虚拟机，像任何虚拟机一样，是计算机的软件实现。它接收以eBPF字节码指令形式存在的程序，这些指令必须转换为在CPU上运行的本机机器指令。在早期的eBPF实现中，字节码指令在内核内被解释执行——即每次运行eBPF程序时，内核都会检查指令并将其转换为机器代码，然后执行它们。由于性能原因以及为了避免eBPF解释器中的一些Spectre相关漏洞，解释执行已基本被JIT（即时）编译所取代。编译意味着在程序加载到内核时就一次性完成了到本机机器指令的转换。

eBPF字节码由一组指令组成，这些指令作用于（虚拟的）eBPF寄存器。eBPF指令集和寄存器模型被设计为能整齐地映射到常见的CPU架构，因此从字节码到机器码的编译或解释步骤相对简单。


## eBPF寄存器
eBPF虚拟机使用10个通用寄存器，编号从0到9。此外，寄存器10用作栈帧指针，只能读取，不能写入。在执行BPF程序时，这些寄存器用于存储值以维护状态。

需要注意的是，这些eBPF寄存器在eBPF虚拟机中是软件实现的。它们在Linux内核源代码的[include/uapi/linux/bpf.h](https://elixir.bootlin.com/linux/v6.10-rc5/source/include/uapi/linux/bpf.h)头文件中以BPF_REG_0到BPF_REG_10枚举出现。

、、、
/* Register numbers */
enum {
	BPF_REG_0 = 0,
	BPF_REG_1,
	BPF_REG_2,
	BPF_REG_3,
	BPF_REG_4,
	BPF_REG_5,
	BPF_REG_6,
	BPF_REG_7,
	BPF_REG_8,
	BPF_REG_9,
	BPF_REG_10,
	__MAX_BPF_REG,
};
、、、

在执行eBPF程序之前，上下文参数被加载到寄存器1中。程序执行后，返回值存储在寄存器0中。

在eBPF代码中调用函数时，函数的参数被放置在寄存器1到寄存器5中。如果提供的参数少于五个，则只会使用其中的部分寄存器。
